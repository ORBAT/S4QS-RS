/**
 * Created by teklof on 30.1.15.
 */
var _ = require('lodash');
var util = require('util');
var when = require('when');
var debug = require('debug')('s3-to-rs');
var error = require('debug')('s3-to-rs:error');
error.log = console.error;
var inspect = _.partialRight(util.inspect, {depth: 10});

/**
 * S3Copier polls SQS for S3 object creation events and uses COPY to copy the S3 object data to Redshift.
 *
 * Don't forget to provide credentials in copyParams.
 *
 * @param {String|Function} copyParams.table String with name of table to COPY to, or a function that takes an
 * S3 URI and returns a table name
 * @param {Array} copyParams.args Array of strings to be given as parameterless arguments to COPY. For example
 * ['GZIP', 'TRUNCATECOLUMNS']
 * @param {Object} copyParams.withParams Object with parametrized COPY arguments. For example
 * {'TIMEFORMAT': 'auto', 'NULL': 'null'}
 * @param {Object} poller SQS poller
 * @param {Number} options.pollIntervalS Interval between SQS polls
 * @param {String} options.connStr Connection string for Redshift
 * @param {String} options.tablePostfix Added to the end of the table name generated by
 * copyParams.table. Handy for having different tables based on NODE_ENV
 * @constructor
 * @type {S3Copier}
 */
var S3Copier = exports.S3Copier = function S3Copier(poller, pg, copyParams, options) {
  if(!options) {
    throw new Error("Missing options");
  }

  if(!pg) {
    throw new Error("Missing PostgreSQL module");
  }

  if(!poller) {
    throw new Error("Missing poller");
  }

  if(!options.connStr) {
    throw new Error("missing connection string");
  }

  var table = copyParams.table;
  if(!_.isString(table) && !_.isFunction(table)) {
    throw new Error("copyParams.table must be a string or function");
  }

  if(_.isString(table)) {
    this._tableNamer = _tableStrToNamer(table);
  } else {
    this._tableNamer = table;
  }

  this._pollIntervalS = options.pollIntervalS || 60;

  if(options.tablePostfix) {
    debug("Table postfix " + options.tablePostfix);
    this._tablePostfix = options.tablePostfix; // will be added to the end of the table name
  }

  this._pg = pg;
  this._connStr = options.connStr;
  this._copyTemplate = _copyParamsTempl(copyParams);
  this._poller = poller;
  this.started = false;
  this._timeout = null; // used for setTimeout obj
  this._toDelete = []; // successfully copied messages to be deleted
  // if an _onMsg call is running, this'll contain a promise that'll be fulfilled when the messages
  // have been handled
  this._onMsgPending = null;
};

S3Copier.prototype._connAndCopy = function _connAndCopy(s3URI) {
  var self = this;
  return when.promise(function (resolve, reject) {
    self._pg.connect(self._connStr, function (err, client, done) {
      if(err) {
        error("Error getting Redshift client: " + err);
        done();
        reject(err);
        return;
      }

      var table = self._tableNamer(s3URI);

      if(self._tablePostfix) {
        table += self._tablePostfix;
      }

      var query = util.format(self._copyTemplate, table, s3URI);

      client.query(query, function (err) {
        if(err) {
          done(client);
          reject(err);
          return;
        }
        done();
        resolve(s3URI);
      });
    });
  });
};

S3Copier.prototype._doDelete = function() {
  var self = this;
  debug("Deleting " + this._toDelete.length + " messages");
  return this._poller.deleteMsgs(this._toDelete)
    .then(function() {
      debug("Messages deleted");
      self._toDelete = [];
    })
    .catch(function(err) {
      // TODO: should the _toDelete array be emptied here or not? Not clearing it might cause it to fill up
      error("Error deleting messages: " + err);
    });
};

S3Copier.prototype._onMsgs = function _onMsgs(msgs) {
  debug("Copying " + msgs.length + " files");
  var nextPoll = Date.now() + this._pollIntervalS * 1000
    , self = this
    , pendingDefer = when.defer();

  this._onMsgPending = pendingDefer.promise;

  if(msgs.length == 0) {
    debug("No messages, scheduling new poll.");
    pendingDefer.resolve();
    self._schedulePoll(nextPoll);
    return;
  }

  var copyPs = _.map(msgs, function (msg) {

    var uris = _eventToS3URIs(JSON.parse(msg.Body));

    return when.map(uris, function (uri) {
      return self._connAndCopy(uri).then(function() {
        self._toDelete.push(msg); // mark successfully copied messages for deletion
      }, function(err) {
        error("Error copying " + msg.MessageId + ": " + err);
      })
    });
  });

  when.all(copyPs).done(function() {
    debug("All copied");
    self._doDelete().done(function() {
      pendingDefer.resolve();
      self._schedulePoll(nextPoll);
    });
  });
};

S3Copier.prototype._schedulePoll = function(nextPoll) {
  if(!this.started) {
    return; // bail out early
  }
  var timeLeft = nextPoll - Date.now();

  if(timeLeft < 0) {
    timeLeft = 0;
  }
  debug("Seconds until next poll: " + timeLeft / 1000);
  this._timeout = setTimeout(this._poller.poll.bind(this._poller) , timeLeft);
};


S3Copier.prototype.stop = function() {
  if(this.started) {
    this.started = false;
    debug("Stopping");
    clearTimeout(this._timeout);
    if(this._onMsgPending) {
      return this._onMsgPending;
    }
    return when();
  }
  return when();
};

S3Copier.prototype.start = function start() {
  if(!this.started) {
    debug("Starting");
    this._poller.on('messages', this._onMsgs.bind(this));
    this._poller.poll();
    this.started = true;
  }
};

var _boolish = /^(true|on|false|off)$/i;
var _enc = /^encoding$/i;

var _copyParamsTempl = exports._copyParamsTempl = function _copyParamsTempl(copyParams) {

  copyParams.withParams = copyParams.withParams || {};
  copyParams.args = copyParams.args || [];

  var withp = _.reduce(_.pairs(copyParams.withParams), function (acc, pair) {
    var key = pair[0]
      , value = pair[1];
    if (!(_.isNumber(value) || value.toString().match(_boolish) || key.match(_enc))) {
      // we need quotes since value is not a number or boolean-ish, and the key isn't "encoding"
      value = "'" + value + "'";
    }
    acc.push(key + " " + value);

    return acc;

  }, []);

  return "COPY %s FROM '%s' " + copyParams.args.concat(withp).join(' ') + ";";
};

/**
 * Takes a string and turns it into a function that returns a table name for an S3 URI. If the string starts with
 * a '/' it's assumed to be a regex, and the returned function will use that regex to build table names. If the
 * string doesn't start with a '/', the function will always return whatever 'table' contains.
 * @param {String} table string given in config
 * @return {Function} Function that takes an S3 URI and returns a table name
 * @private
 */
var _tableStrToNamer = exports._tableStrToNamer = function _tableStrToNamer(table) {

  if(_.first(table) === '/') { // happily assume it's a regex
    var lastSlash = _.lastIndexOf(table, '/')
      , pattern = _.initial(_.rest(table)).join('').substring(0,lastSlash - 1)
      , flags = table.substring(lastSlash + 1)
      , re = new RegExp(pattern, flags);

    debug("Using pattern " + pattern + " based on " + table);
    return _.partial(_URIToTbl, re);
  } else {
    return function() {
      return table;
    };
  }
};

var _URIToTbl = exports._URIToTbl = function(regex, uri) {
  var match = uri.match(regex);
  if(match && match[1]) {
    return match[1].split('.').join('_');
  } else {
    throw new Error("Can't turn '" + uri + "' into table name with regex " + regex);
  }
};
/**
 * Takes an S3 event and returns an array of S3 URIs contained in the Records field.
 * @param {Object} evt S3 event
 * @return {Array} S3 URI strings
 */
var _eventToS3URIs = exports._eventToS3URIs = function _eventToS3URIs(evt) {
  if(evt.Type === "Notification") {
    error("Suspicious SQS message. Are you sure the SNS message delivery is set to raw?");
    return [];
  }

  if (_.isArray(evt.Records) && evt.Records.length > 0) {
    return _.reduce(evt.Records, function (acc, record) {
      var s3 = record.s3;
      if (record.eventVersion == "2.0" && s3 && s3.s3SchemaVersion == "1.0") {
        acc.push("s3://" + s3.bucket.name + "/" + s3.object.key)
      } else {
        error("Unknown event (" + record.eventVersion + ") or S3 event version (" +
              ((s3 && s3.s3SchemaVersion) || "N/A") + ")");
      }
      return acc;
    }, []);
  }
  return [];
};