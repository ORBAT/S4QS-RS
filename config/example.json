{
  // S4QS-RS will start a HTTP server at this port, with the route /check
  // which returns the string OK. Omit to disable.
  "HTTPPort": 9999,
  // SQS poller options. 
  // Optional.
  "SQS": {
    "poller": {
      // repeat the poll this many times when fetching new messages from SQS.
      // You'll get at most repeatPoll * MaxNumberOfMessages messages at once.
      // Optional, defaults to 1.
      "repeatPoll": 5
    },
    // SQS region.
    // Required.
    "region": "us-east-1",
    // parameters to pass to SQS. See http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/SQS.html.
    // Required, and at least QueueUrl must be present.
    "params": {
      "QueueUrl": "https://sqs.us-east-1.amazonaws.com/123456789/some-queue-name",
      "WaitTimeSeconds": 20,
      "MaxNumberOfMessages": 10
    }
  },

  "S3Copier": {
    // AWS Redshift options.
    // Required.
    "Redshift": {
      /*if the Redshift cluster's status goes to anything but "available",
       pause all operation, and try checking its status at intervals of
       clusterAvailCheckInterval. When cluster goes back up, resume
       everything.

       Set this to -1 to exit if the cluster becomes unavailable.

       Optional. Defaults to -1. */
      "clusterAvailCheckInterval": 300,
      // Redshift connection string.
      // Required.
      "connStr": "postgres://username:password@example.com:5439/schema",
      // cluster region.
      // Required.
      "region": "us-east-1",
      // bound parameters. ClusterIdentifier is required, others are optional
      "params": {
        // cluster ID.
        // Required.
        "ClusterIdentifier": "mycluster"
      }
    },
    // AWS S3 constructor options, used by the manifest uploader.
    // Required. ACL must be defined here, other parameters are optional.
    "S3": {
      "params": {
        "ACL": "bucket-owner-full-control"
      }
    },
    // Manifest uploader options.
    // Required.
    "manifestUploader": {
      // Maximum number of URIs to have in each manifest (see maxWaitSeconds)
      // Required.
      "maxToUpload": 25,
      // Upload manifests at intervals of maxWaitSeconds seconds, as long as they have over 0 messages.
      // Required.
      "maxWaitSeconds": 600,
      // Value of "mandatory" property of manifest items.
      // Required.
      "mandatory": true,
      // Bucket to upload manifests to.
      // Required.
      "bucket": "manifest-bucket",
      // Prefix for manifest keys.
      // Required.
      "prefix": "s4qs/manifests/",
      // How many times uploads should be retried. Retries have a backoff of 1.5^nRetries * 1000ms, so the first
      // retry will happen after 1000ms, the 2nd after 1500ms, the 3rd after 2250ms, 4th after 3375ms etc.
      // S4QS will throw an exception and exit if the upload fails despite the retries.
      // Optional, will default to 0, meaning S4QS will exit immediately on the first upload error.
      "retries": 5
    },
    // LRU cache options. Used for message deduplication.
    // Optional. See https://github.com/isaacs/node-lru-cache for possible options.
    "LRU": {
      "max": 1000
    },
    // how often to poll for new messages from SQS.
    // Required.
    "pollIntervalSeconds": 300,
    // this will be added to the end of the table name when doing COPYs.
    // Useful for having different tables for different NODE_ENVs.
    // Optional.
    "tablePostfix": "_devel",

    // parameters for Redshift's COPY query.
    // Required.
    "copyParams": {
      // Redshift schema to use
      "schema": "myschema",
      /*
       the "table" property is used to build the "base" of the Redshift table name. table can be either a string
       like "my_table_name" or a regular expression (which must start and end with a /).
       The regular expression is given an S3 URI (s3://bucket-name/some/key), and the first capture group
       will be used as the table name.

       When using a regex, periods in the S3 URI are converted to underscores but that's it as far as sanitization for
       Redshift goes.
       Feed it weird URIs and weird stuff will probably happen.

       The regex, tablePostfix and timeSeries settings in this example would turn URIs like
       s3://bucketname/whatevs/some.table.name/somefilename.csv.gz
       to time series tables that have names like "some_table_name_devel_ts_1428883200",
       and the rolling view would have the name "some_table_name_view_devel".

       If you use Javascript configuration files, you can specify a function
       for "table". The function must take an S3 URI and output a valid
       Redshift table name.
       */
      "table": "/s3:\/\/.*?\/whatevs\/(.*?)\//i",
      // parameterless arguments to COPY. See http://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html.
      // Optional.
      "args": [
        "GZIP",
        "TRUNCATECOLUMNS"
      ],
      // parameters with arguments to COPY.
      // Boolean arguments can be either true/false, "true"/"false" or "on"/"off".
      // Can be overridden easily in NODE_ENV-specific configuration.
      // Technically optional, although you'll probably want some.
      "withParams": {
        "DELIMITER": "\\t",
        "REGION": "us-east-1",
        "MAXERROR": 100,
        "NULL": "null",
        "TIMEFORMAT": "auto"
      }
    },
    /*
     S4QS-RS can either copy data into a single, monolithic table, or it can use time series time series tables with a
     configurable time period.

     Multiple automatically updating UNION ALL + SELECT views of the tables can be created. A configurable amount of
     old tables can be retained, and old tables are dropped when needed.

     The keys of tableConfig should match table names produced by copyParams.table. The keys are used to match
     table configuration to incoming S3 files.

     See e.g. http://docs.aws.amazon.com/redshift/latest/dg/vacuum-time-series-tables.html for more information
     on the concept.

     Required. Sub-object properties are required unless otherwise noted.
     */
    "tableConfig": {
      // time series table configuration for the base table some_table_name (extracted from S3 URI by regex in the
      // "table" property above)
      "some_table_name": {
        // Time series table period in seconds. A value of e.g. 86400 would mean that a new time series table is
        // created per every day
        "period": 86400,
        // Keep a maximum of maxTables time series tables. Oldest tables will be deleted first
        "maxTables": 30,
        // How many rolling views to create, and how many tables each view
        // should contain.
        // The example would create 4 views with lengths 1, 5, 15 and 30.
        // Can be either an array or a single number.
        // Optional. Will default to maxTables if omitted.
        "tablesInView": [1, 5, 15, 30],
        // Array of column definitions
        "columns": ["SOURCE INT NOT NULL ENCODE BYTEDICT",  "ID CHAR(24) ENCODE LZO DISTKEY", "..."],
        // Array of table attributes
        "tableAttrs": ["DISTKEY(ID)", "SORTKEY(ID)"]
      },
      // NOTE that this table has no time series configuration, so other_table_name_devel will be used as table name
      "other_table_name": {
        "columns": ["AHOY INT NOT NULL ENCODE LZO",  "DERR INT ENCODE DELTA DISTKEY", "..."],
        "tableAttrs": ["DISTKEY(AHOY)", "SORTKEY(DERR)"]
      }
    }
  }
}